<!DOCTYPE html>
<html lang="ro">
<head>
<meta charset="UTF-8" />
<title>Text împărțit și aliniat față de imagine</title>
<style>
  .wrap-span {
    display: flex;
    align-items: flex-start;
    gap: 1rem;
    padding: 1rem;
    position: relative;
    border: 1px solid #ccc;
    width: 80%; /* ajustare pentru testare */
    max-width: 800px; /* pentru ecran mai larg */
    height: auto;
  }
  .image-container {
    flex-shrink: 0;
  }
  #text-area {
    position: relative;
  }
  /* Stil pentru rânduri */
  .line {
    white-space: nowrap;
    margin: 4px 0;
  }
</style>
</head>
<body>

<div class="wrap-span" id="wrap">
  <div class="image-container">
    <img src="https://github.com/scoalanicualbu/website/blob/main/prezentare/mec.png?raw=true" alt="Imagine" id="imagine" />
  </div>
  <div id="text-area"></div>
</div>

<script>
const text = "Acesta este un exemplu de text lung care trebuie împărțit dinamic pe rânduri și aliniat corespunzător.";
const container = document.getElementById('text-area');

function impareazaText() {
  container.innerHTML = '';

  const cuvinte = text.split(' ');
  const img = document.getElementById('imagine');

  // Măsurăm dimensiuni
  const wrapRect = document.getElementById('wrap').getBoundingClientRect();
  const imagineRect = img.getBoundingClientRect();

  // Max latime pentru rânduri
  const maxLatime = wrapRect.width - (imagineRect.right - wrapRect.left) - 20;

  // Funcție pentru măsurarea cuvânt
  function masoaraCuvant(cuvant) {
    const span = document.createElement('span');
    span.style.visibility = 'hidden';
    span.style.position = 'absolute';
    span.style.whiteSpace = 'nowrap';
    span.innerText = cuvant;
    document.body.appendChild(span);
    const latime = span.offsetWidth;
    document.body.removeChild(span);
    return latime;
  }

  // Împărțim în rânduri
  const randuri = [];
  let randCurent = [];
  let latimeCurenta = 0;

  cuvinte.forEach(cuvant => {
    const latimeCuvant = masoaraCuvant(cuvant);
    if (latimeCuvant + latimeCurenta + 8 < maxLatime || randCurent.length === 0) {
      randCurent.push(cuvant);
      latimeCurenta += latimeCuvant + 8;
    } else {
      randuri.push(randCurent);
      randCurent = [cuvant];
      latimeCurenta = latimeCuvant + 8;
    }
  });
  if (randCurent.length > 0) randuri.push(randCurent);

  // Găsim rândul cel mai lung
  let maxLength = 0;
  let indexMax = 0;
  randuri.forEach((r, i) => {
    const totalWidth = r.reduce((sum, c) => sum + masoaraCuvant(c) + 8, -8);
    if (totalWidth > maxLength) {
      maxLength = totalWidth;
      indexMax = i;
    }
  });

  // Creăm și afișăm rândul cel mai lung
  const celMaiLungRand = document.createElement('div');
  celMaiLungRand.className = 'line';
  celMaiLungRand.innerText = randuri[indexMax].join(' ');
  container.appendChild(celMaiLungRand);

  // Măsurăm dimensiuni și poziție
  const maxLineRect = celMaiLungRand.getBoundingClientRect();
  const wrapRect = document.getElementById('wrap').getBoundingClientRect();

  // Calculăm poziția față de marginea imaginii plus 0.5rem (8px)
  const desiredLeft = imagineRect.right - wrapRect.left + 8;

  // Limite pentru poziție
  const containerWidth = wrapRect.width;
  const maxAllowedLeft = containerWidth - maxLineRect.width;
  const finalLeft = Math.min(Math.max(desiredLeft, 0), maxAllowedLeft);

  // Poziționăm rândul cel mai lung
  celMaiLungRand.style.position = 'absolute';
  celMaiLungRand.style.top = '0px';
  celMaiLungRand.style.left = finalLeft + 'px';

  // Creăm și poziționăm celelalte rânduri, centrate față de cel mai lung
  const alteDivs = [];
  for (let i = 0; i < randuri.length; i++) {
    if (i === indexMax) continue;
    const div = document.createElement('div');
    div.className = 'line';
    div.innerText = randuri[i].join(' ');
    container.appendChild(div);
    alteDivs.push(div);
  }

  // Poziționare celelalte rânduri după cel mai lung
  setTimeout(() => {
    const maxLineBCR = celMaiLungRand.getBoundingClientRect();
    alteDivs.forEach(div => {
      const divBCR = div.getBoundingClientRect();
      const newLeft = finalLeft + (maxLineBCR.width - divBCR.width) / 2;
      div.style.position = 'absolute';
      div.style.top = (parseFloat(celMaiLungRand.style.top) + maxLineBCR.height + 4) + 'px';
      div.style.left = Math.max(0, Math.min(newLeft, containerWidth - divBCR.width)) + 'px';
    });
  }, 0);
}

// Reapelare la redimensionare
window.addEventListener('resize', impareazaText);
impareazaText();
</script>

</body>
</html>
